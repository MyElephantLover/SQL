-- Postgre SQL has a lot of features, but some of them are not widely used. So the goal of this task is to embark on an exciting adventure of creating a new SQL type with user defined operations. An obvious candidate is a type representing rational numbers (conveniently Ruby has Rational class so we could see it as an example behaviour for some tests). For easy version lets declare a composite type and restrict to features we could implement with it.

-- Task: define composite type rational with following features:

-- long enough numerator and denominator (more than 30 decimal digits)
-- type casts from/to integer, bigint, numeric, text or varchar. i.e. '-11/2'::text::rational should work, as well as '(-11,2)'::rational::text, 15.5::numeric::rational, etc. '(-14,15)'::rational::bigint should be equal to 0.
-- 'rational(15,7)' should also work as a convenient way to construct a rational value
-- arithmetic operators +, - (binary and unary), *, /, %
-- comparison operators =, <>, <, >, <=, >=
-- functions numerator(r rational), denominator(r rational) and unary operators ?/- and -/? as aliases for them. why? because we can.
-- binary operators should work with rational/bigint mix
-- it should be in reduced form where possible
-- Notes:

-- look at sample tests for the exact behaviour
-- division by zero will not be tested
-- reduced fractions should have a positive denominator
-- for the '%' operator, the sign of the remainder should be equal to the sign of the dividend (so the behaviour will be consistent with the same operator for integer type)

-- This question is long and not that common and useful. 
-- include here for educational purpose (code generated by AI)

-- ============================================================
-- RATIONAL TYPE (composite) + casts + operators + functions
-- ============================================================

DROP TYPE IF EXISTS rational CASCADE;

-- 1) TYPE
CREATE TYPE rational AS (
  n numeric,
  d numeric
);

-- 2) HELPERS: gcd + normalization/reduction
CREATE OR REPLACE FUNCTION rational_gcd(a numeric, b numeric)
RETURNS numeric
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  x numeric := abs(a);
  y numeric := abs(b);
  t numeric;
BEGIN
  IF x = 0 THEN RETURN y; END IF;
  IF y = 0 THEN RETURN x; END IF;

  WHILE y <> 0 LOOP
    t := mod(x, y);
    x := y;
    y := t;
  END LOOP;

  RETURN x;
END;
$$;

CREATE OR REPLACE FUNCTION rational_make(nn numeric, dd numeric)
RETURNS rational
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  n numeric := trunc(nn);
  d numeric := trunc(dd);
  g numeric;
BEGIN
  IF d < 0 THEN
    n := -n;
    d := -d;
  END IF;

  IF n = 0 THEN
    RETURN ROW(0::numeric, 1::numeric)::rational;
  END IF;

  g := rational_gcd(n, d);
  IF g <> 0 THEN
    n := trunc(n / g);
    d := trunc(d / g);
  END IF;

  IF d < 0 THEN
    n := -n;
    d := -d;
  END IF;

  RETURN ROW(n, d)::rational; -- ROW() here construct a row value (a composite value)
END;
$$;

-- convenient constructor: rational(15,7)
CREATE OR REPLACE FUNCTION rational(nn numeric, dd numeric)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make($1, $2)
$$;

-- 3) TEXT IO FOR CASTS: '(n,d)' OR 'n/d' OR 'n'
CREATE OR REPLACE FUNCTION rational_from_text(s text)
RETURNS rational
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  t text := btrim(s);
  a text;
  b text;
  n numeric;
  d numeric;
BEGIN
  IF t ~ '^\(\s*[-+]?\d+(\.\d+)?\s*,\s*[-+]?\d+(\.\d+)?\s*\)$' THEN
    t := regexp_replace(t, '^\(\s*', '');
    t := regexp_replace(t, '\s*\)$', '');
    a := btrim(split_part(t, ',', 1));
    b := btrim(split_part(t, ',', 2));
    n := a::numeric;
    d := b::numeric;
    RETURN rational_make(n, d);
  END IF;

  IF t ~ '^\s*[-+]?\d+(\.\d+)?\s*/\s*[-+]?\d+(\.\d+)?\s*$' THEN
    a := btrim(split_part(t, '/', 1));
    b := btrim(split_part(t, '/', 2));
    n := a::numeric;
    d := b::numeric;
    RETURN rational_make(n, d);
  END IF;

  n := t::numeric;
  RETURN rational_make(n, 1);
END;
$$;

CREATE OR REPLACE FUNCTION rational_to_text(r rational)
RETURNS text
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
           WHEN (t.x).d = 1 THEN (t.x).n::text
           ELSE (t.x).n::text || '/' || (t.x).d::text
         END
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

-- 4) CASTS
CREATE CAST (text AS rational) WITH FUNCTION rational_from_text(text) AS IMPLICIT;
CREATE CAST (varchar AS rational) WITH FUNCTION rational_from_text(text) AS IMPLICIT;

CREATE CAST (rational AS text) WITH FUNCTION rational_to_text(rational) AS IMPLICIT;
CREATE CAST (rational AS varchar) WITH FUNCTION rational_to_text(rational) AS IMPLICIT;

CREATE OR REPLACE FUNCTION rational_from_int(x integer)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$ SELECT rational_make(x::numeric, 1::numeric) $$;

CREATE OR REPLACE FUNCTION rational_from_bigint(x bigint)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$ SELECT rational_make(x::numeric, 1::numeric) $$;

CREATE CAST (integer AS rational) WITH FUNCTION rational_from_int(integer) AS IMPLICIT;
CREATE CAST (bigint  AS rational) WITH FUNCTION rational_from_bigint(bigint)  AS IMPLICIT;

CREATE OR REPLACE FUNCTION rational_from_numeric(x numeric)
RETURNS rational
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  s int;
  denom numeric;
  numer numeric;
BEGIN
  s := scale(x); -- scale() means to return the number of digits to the decimal point to the right of a numeric
  IF s <= 0 THEN
    RETURN rational_make(x, 1);
  END IF;

  denom := (10::numeric ^ s);
  numer := x * denom;
  RETURN rational_make(numer, denom);
END;
$$;

CREATE CAST (numeric AS rational) WITH FUNCTION rational_from_numeric(numeric) AS IMPLICIT;

CREATE OR REPLACE FUNCTION rational_to_numeric(r rational)
RETURNS numeric
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((t.x).n / (t.x).d)
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

CREATE CAST (rational AS numeric) WITH FUNCTION rational_to_numeric(rational);

CREATE OR REPLACE FUNCTION rational_to_bigint(r rational)
RETURNS bigint
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT trunc((t.x).n / (t.x).d)::bigint
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

CREATE OR REPLACE FUNCTION rational_to_int(r rational)
RETURNS integer
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT trunc((t.x).n / (t.x).d)::integer
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

CREATE CAST (rational AS bigint) WITH FUNCTION rational_to_bigint(rational);
CREATE CAST (rational AS integer) WITH FUNCTION rational_to_int(rational);

-- 5) ACCESSORS
CREATE OR REPLACE FUNCTION numerator(r rational)
RETURNS bigint
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT (t.x).n::bigint
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

CREATE OR REPLACE FUNCTION denominator(r rational)
RETURNS bigint
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT (t.x).d::bigint
  FROM (SELECT rational_make(r.n, r.d) AS x) t
$$;

-- 6) ARITHMETIC
CREATE OR REPLACE FUNCTION rational_add(a rational, b rational)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make((ra.x).n*(rb.x).d + (rb.x).n*(ra.x).d, (ra.x).d*(rb.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_sub(a rational, b rational)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make((ra.x).n*(rb.x).d - (rb.x).n*(ra.x).d, (ra.x).d*(rb.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_mul(a rational, b rational)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make((ra.x).n*(rb.x).n, (ra.x).d*(rb.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_div(a rational, b rational)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make((ra.x).n*(rb.x).d, (ra.x).d*(rb.x).n)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_uminus(a rational)
RETURNS rational
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT rational_make(-(t.x).n, (t.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) t
$$;

CREATE OR REPLACE FUNCTION rational_mod(a rational, b rational)
RETURNS rational
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  ra rational := rational_make(a.n,a.d);
  rb rational := rational_make(b.n,b.d);
  q numeric;
BEGIN
  q := trunc( (ra.n*rb.d) / (ra.d*rb.n) );
  RETURN rational_sub(ra, rational_mul(rb, rational_make(q, 1)));
END;
$$;

-- 7) COMPARISONS
CREATE OR REPLACE FUNCTION rational_eq(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d = (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_ne(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d <> (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_lt(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d < (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_le(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d <= (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_gt(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d > (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

CREATE OR REPLACE FUNCTION rational_ge(a rational, b rational)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT ((ra.x).n*(rb.x).d >= (rb.x).n*(ra.x).d)
  FROM (SELECT rational_make(a.n,a.d) AS x) ra,
       (SELECT rational_make(b.n,b.d) AS x) rb
$$;

-- 8) OPERATORS
CREATE OPERATOR + (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_add, COMMUTATOR = +);
CREATE OPERATOR - (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_sub);
CREATE OPERATOR * (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_mul, COMMUTATOR = *);
CREATE OPERATOR / (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_div);
CREATE OPERATOR % (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_mod);

CREATE OPERATOR - (RIGHTARG = rational, PROCEDURE = rational_uminus);

CREATE OPERATOR =  (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_eq, COMMUTATOR = =,  NEGATOR = <>);
CREATE OPERATOR <> (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_ne, COMMUTATOR = <>, NEGATOR = =);
CREATE OPERATOR <  (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_lt, COMMUTATOR = >,  NEGATOR = >=);
CREATE OPERATOR <= (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_le, COMMUTATOR = >=, NEGATOR = >);
CREATE OPERATOR >  (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_gt, COMMUTATOR = <,  NEGATOR = <=);
CREATE OPERATOR >= (LEFTARG = rational, RIGHTARG = rational, PROCEDURE = rational_ge, COMMUTATOR = <=, NEGATOR = <);

-- weird unary aliases
CREATE OPERATOR ?/- (RIGHTARG = rational, PROCEDURE = numerator);
CREATE OPERATOR -/? (RIGHTARG = rational, PROCEDURE = denominator);
